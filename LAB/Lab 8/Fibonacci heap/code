#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>

typedef struct FibNode {
    int key;
    int degree;
    int mark;
    struct FibNode *parent;
    struct FibNode *child;
    struct FibNode *left;
    struct FibNode *right;
} FibNode;

typedef struct FibonacciHeap {
    FibNode *min;
    int n;
} FibonacciHeap;

// Function declarations
FibonacciHeap* createHeap();
FibNode* createNode(int key);
void fibInsert(FibonacciHeap *H, FibNode *x);
FibNode* fibMinimum(FibonacciHeap *H);
FibNode* fibExtractMin(FibonacciHeap *H);
void consolidate(FibonacciHeap *H);
void fibLink(FibonacciHeap *H, FibNode *y, FibNode *x);
void fibDecreaseKey(FibonacciHeap *H, FibNode *x, int k);
void cut(FibonacciHeap *H, FibNode *x, FibNode *y);
void cascadingCut(FibonacciHeap *H, FibNode *y);
void fibDelete(FibonacciHeap *H, FibNode *x);
void displayRootList(FibonacciHeap *H);

// Create empty Fibonacci heap
FibonacciHeap* createHeap() {
    FibonacciHeap *H = (FibonacciHeap*)malloc(sizeof(FibonacciHeap));
    H->min = NULL;
    H->n = 0;
    return H;
}

// Create a new node
FibNode* createNode(int key) {
    FibNode *x = (FibNode*)malloc(sizeof(FibNode));
    x->key = key;
    x->degree = 0;
    x->mark = 0;
    x->parent = NULL;
    x->child = NULL;
    x->left = x->right = x;
    return x;
}

// Insert node into heap
void fibInsert(FibonacciHeap *H, FibNode *x) {
    if (H->min == NULL) {
        H->min = x;
    } else {
        x->left = H->min;
        x->right = H->min->right;
        H->min->right->left = x;
        H->min->right = x;

        if (x->key < H->min->key)
            H->min = x;
    }
    H->n++;
}

// Return minimum
FibNode* fibMinimum(FibonacciHeap *H) {
    return H->min;
}

// Extract the minimum node
FibNode* fibExtractMin(FibonacciHeap *H) {
    FibNode *z = H->min;
    if (z != NULL) {
        // Move each child of z to root list
        if (z->child != NULL) {
            FibNode *c = z->child;
            do {
                FibNode *next = c->right;
                c->parent = NULL;

                c->left = H->min;
                c->right = H->min->right;
                H->min->right->left = c;
                H->min->right = c;

                c = next;
            } while (c != z->child);
        }

        // Remove z from root list
        z->left->right = z->right;
        z->right->left = z->left;

        if (z == z->right) {
            H->min = NULL;
        } else {
            H->min = z->right;
            consolidate(H);
        }
        H->n--;
    }
    return z;
}

// Link two trees
void fibLink(FibonacciHeap *H, FibNode *y, FibNode *x) {
    y->left->right = y->right;
    y->right->left = y->left;

    y->parent = x;
    if (x->child == NULL) {
        x->child = y;
        y->left = y->right = y;
    } else {
        y->left = x->child;
        y->right = x->child->right;
        x->child->right->left = y;
        x->child->right = y;
    }
    x->degree++;
    y->mark = 0;
}

// Consolidate trees after extract-min
void consolidate(FibonacciHeap *H) {
    int D = (int)(log(H->n) / log(2)) + 5;
    FibNode **A = calloc(D, sizeof(FibNode*));

    FibNode *w = H->min;
    if (!w) return;

    FibNode *start = w;

    do {
        FibNode *x = w;
        int d = x->degree;

        while (A[d] != NULL) {
            FibNode *y = A[d];
            if (x->key > y->key) {
                FibNode *temp = x;
                x = y;
                y = temp;
            }
            fibLink(H, y, x);
            A[d] = NULL;
            d++;
        }
        A[d] = x;
        w = w->right;
    } while (w != start);

    H->min = NULL;

    for (int i = 0; i < D; i++) {
        if (A[i] != NULL) {
            if (H->min == NULL)
                H->min = A[i];
            else {
                A[i]->left = H->min;
                A[i]->right = H->min->right;
                H->min->right->left = A[i];
                H->min->right = A[i];

                if (A[i]->key < H->min->key)
                    H->min = A[i];
            }
        }
    }
    free(A);
}

// Decrease-key
void fibDecreaseKey(FibonacciHeap *H, FibNode *x, int k) {
    if (k > x->key) {
        printf("Error: New key is greater than current key.\n");
        return;
    }
    x->key = k;
    FibNode *y = x->parent;

    if (y != NULL && x->key < y->key) {
        cut(H, x, y);
        cascadingCut(H, y);
    }

    if (x->key < H->min->key)
        H->min = x;
}

// Cut x from y
void cut(FibonacciHeap *H, FibNode *x, FibNode *y) {
    if (x->right == x)
        y->child = NULL;
    else {
        x->right->left = x->left;
        x->left->right = x->right;
        if (y->child == x)
            y->child = x->right;
    }
    y->degree--;

    x->parent = NULL;
    x->mark = 0;

    x->left = H->min;
    x->right = H->min->right;
    H->min->right->left = x;
    H->min->right = x;
}

// Cascading cut
void cascadingCut(FibonacciHeap *H, FibNode *y) {
    FibNode *z = y->parent;
    if (z != NULL) {
        if (y->mark == 0)
            y->mark = 1;
        else {
            cut(H, y, z);
            cascadingCut(H, z);
        }
    }
}

// Delete node
void fibDelete(FibonacciHeap *H, FibNode *x) {
    fibDecreaseKey(H, x, INT_MIN);
    fibExtractMin(H);
}

// Show current root list
void displayRootList(FibonacciHeap *H) {
    if (H->min == NULL) {
        printf("Root List: EMPTY\n");
        return;
    }

    FibNode *temp = H->min;
    printf("Root List: ");
    do {
        printf("%d ", temp->key);
        temp = temp->right;
    } while (temp != H->min);
    printf("\n");
}

// ----------------------------------------------------
//                     MAIN PROGRAM
// ----------------------------------------------------
int main() {
    FibonacciHeap *H = createHeap();

    int choice, key, newKey;
    FibNode *nodes[1000]; 
    int count = 0;

    while (1) {
        printf("\n=== Fibonacci Heap Menu ===\n");
        printf("1. Insert\n");
        printf("2. Find-Min\n");
        printf("3. Extract-Min\n");
        printf("4. Decrease-Key\n");
        printf("5. Delete\n");
        printf("6. Display Root List\n");
        printf("7. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert: ");
                scanf("%d", &key);
                nodes[count] = createNode(key);
                fibInsert(H, nodes[count]);
                count++;
                break;

            case 2:
                if (H->min)
                    printf("Minimum = %d\n", H->min->key);
                else
                    printf("Heap is empty.\n");
                break;

            case 3: {
                FibNode *min = fibExtractMin(H);
                if (min)
                    printf("Extracted Min = %d\n", min->key);
                else
                    printf("Heap is empty.\n");
                break;
            }

            case 4:
                printf("Enter existing key: ");
                scanf("%d", &key);
                printf("Enter new smaller key: ");
                scanf("%d", &newKey);

                for (int i = 0; i < count; i++) {
                    if (nodes[i] && nodes[i]->key == key) {
                        fibDecreaseKey(H, nodes[i], newKey);
                        break;
                    }
                }
                break;

            case 5:
                printf("Enter key to delete: ");
                scanf("%d", &key);

                for (int i = 0; i < count; i++) {
                    if (nodes[i] && nodes[i]->key == key) {
                        fibDelete(H, nodes[i]);
                        nodes[i] = NULL;
                        break;
                    }
                }
                break;

            case 6:
                displayRootList(H);
                break;

            case 7:
                exit(0);

            default:
                printf("Invalid choice!\n");
        }
    }

    return 0;
}
