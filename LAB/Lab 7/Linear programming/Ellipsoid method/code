/*
 * Ellipsoid method for Linear Programming feasibility:
 * Find x such that A x <= b
 *
 * Compile:  gcc ellipsoid_lp.c -o ellipsoid_lp -lm
 */

#include <stdio.h>
#include <math.h>

#define MAX_M 200   // max number of constraints
#define MAX_N 20    // max dimension
#define MAX_ITERS 10000
#define EPS 1e-8

int main() {
    int m, n;
    int i, j, k, iter;
    double A[MAX_M][MAX_N];
    double b[MAX_M];

    // Ellipsoid parameters
    double x[MAX_N];           // center
    double H[MAX_N][MAX_N];    // shape matrix
    double newH[MAX_N][MAX_N];
    double R;                  // initial radius

    printf("Ellipsoid Algorithm for LP Feasibility: A x <= b\n");

    printf("Enter number of variables n (<= %d): ", MAX_N);
    scanf("%d", &n);

    printf("Enter number of constraints m (<= %d): ", MAX_M);
    scanf("%d", &m);

    if (n <= 0 || n > MAX_N || m <= 0 || m > MAX_M) {
        printf("Invalid m or n.\n");
        return 1;
    }

    printf("Enter matrix A (m rows, each with n entries):\n");
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            scanf("%lf", &A[i][j]);
        }
    }

    printf("Enter vector b (m entries):\n");
    for (i = 0; i < m; i++) {
        scanf("%lf", &b[i]);
    }

    printf("Enter initial radius R for bounding ball (e.g., 10): ");
    scanf("%lf", &R);

    if (R <= 0) {
        printf("Radius must be positive.\n");
        return 1;
    }

    // Initialize center x = 0
    for (i = 0; i < n; i++) x[i] = 0.0;

    // Initialize H = R^2 * I (ball of radius R)
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            H[i][j] = (i == j) ? (R * R) : 0.0;
        }
    }

    // Main ellipsoid loop
    for (iter = 0; iter < MAX_ITERS; iter++) {
        // 1. Check feasibility of current center x
        int violated_index = -1;
        double max_violation = -1.0;

        for (i = 0; i < m; i++) {
            double ax = 0.0;
            for (j = 0; j < n; j++) {
                ax += A[i][j] * x[j];
            }
            double violation = ax - b[i];
            if (violation > max_violation) {
                max_violation = violation;
                violated_index = i;
            }
        }

        if (max_violation <= EPS) {
            // Feasible point found
            printf("\nFeasible solution found after %d iterations:\n", iter);
            for (i = 0; i < n; i++) {
                printf("x[%d] = %.10f\n", i, x[i]);
            }
            return 0;
        }

        // 2. Use most violated constraint as separating hyperplane
        double *a = A[violated_index];

        // Compute a^T H a
        double Ha[MAX_N];
        double aHa = 0.0;

        for (i = 0; i < n; i++) {
            Ha[i] = 0.0;
            for (j = 0; j < n; j++) {
                Ha[i] += H[i][j] * a[j];
            }
        }
        for (i = 0; i < n; i++) {
            aHa += a[i] * Ha[i];
        }

        if (aHa <= 0.0) {
            printf("Numerical issue: a^T H a <= 0. Stopping.\n");
            break;
        }

        double sqrt_aHa = sqrt(aHa);

        // Normalized direction g = a / sqrt(a^T H a)
        double g[MAX_N];
        for (i = 0; i < n; i++) {
            g[i] = a[i] / sqrt_aHa;
        }

        // Compute H * g
        double Hg[MAX_N];
        for (i = 0; i < n; i++) {
            Hg[i] = 0.0;
            for (j = 0; j < n; j++) {
                Hg[i] += H[i][j] * g[j];
            }
        }

        // 3. Update center: x' = x - (1/(n+1)) H g
        double alpha = 1.0 / (n + 1.0);
        for (i = 0; i < n; i++) {
            x[i] = x[i] - alpha * Hg[i];
        }

        // 4. Update shape matrix:
        // H' = (n^2 / (n^2 - 1)) * ( H - (2/(n+1)) * H g g^T H )
        double beta = 2.0 / (n + 1.0);
        double factor = (n * n) / (double)(n * n - 1.0);

        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                newH[i][j] = H[i][j] - beta * Hg[i] * Hg[j];
                newH[i][j] *= factor;
            }
        }

        // Copy newH back to H
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                H[i][j] = newH[i][j];
            }
        }

        // Optional: you can add a small check if H becomes "too small" or ill-conditioned
    }

    printf("\nMaximum iterations reached (%d). No feasible solution found (or not detected).\n", MAX_ITERS);
    return 0;
}
