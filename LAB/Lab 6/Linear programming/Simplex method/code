#include <stdio.h>
#include <stdlib.h>

#define MAX 20   // Support larger LPs

void printTable(double table[MAX][MAX], int m, int totalVars, int basicVar[]) {
    printf("\n------------------- Simplex Tableau -------------------\n");

    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= totalVars; j++) {
            printf("%10.2lf ", table[i][j]);
        }
        printf("\n");
    }

    printf("Basic Vars: ");
    for (int i = 0; i < m; i++)
        printf("x%d ", basicVar[i] + 1);
    printf("\n--------------------------------------------------------\n");
}

int main() {
    int m, n;
    double table[MAX][MAX];
    int basicVar[MAX];
    double ratio[MAX];
    int pivotRow, pivotCol;
    double pivot;

    printf("Enter number of constraints: ");
    scanf("%d", &m);
    printf("Enter number of variables: ");
    scanf("%d", &n);

    int totalVars = n + m;   // decision vars + slack vars
    int rhs = totalVars;     // RHS column index

    // ---------------- INPUT CONSTRAINTS ----------------
    printf("\nEnter coefficients of constraints:\n");

    for (int i = 0; i < m; i++) {
        printf("\nConstraint %d:\n", i + 1);

        // Coeffs of x vars
        for (int j = 0; j < n; j++) {
            printf("Coefficient of x%d: ", j + 1);
            scanf("%lf", &table[i][j]);
        }

        // Slack vars
        for (int j = n; j < totalVars; j++)
            table[i][j] = (j - n == i) ? 1 : 0;

        // RHS
        printf("Right-hand side: ");
        scanf("%lf", &table[i][rhs]);
    }

    // ---------------- INPUT OBJECTIVE FUNCTION ----------------
    printf("\nEnter coefficients of objective function Z = c1*x1 + ... :\n");
    for (int j = 0; j < n; j++) {
        printf("Coefficient of x%d: ", j + 1);
        scanf("%lf", &table[m][j]);
        table[m][j] = -table[m][j];   // Convert to maximization tableau
    }

    // Slack coefficients in Z row = 0
    for (int j = n; j < totalVars; j++)
        table[m][j] = 0;

    table[m][rhs] = 0;

    // Initial basic variables are slack variables
    for (int i = 0; i < m; i++)
        basicVar[i] = n + i;

    printf("\nInitial Tableau:");
    printTable(table, m, totalVars, basicVar);

    // ---------------- SIMPLEX ITERATION ----------------
    while (1) {
        // Step 1: Select entering variable (most negative Z coefficient)
        pivotCol = -1;
        double mostNegative = 0;

        for (int j = 0; j < totalVars; j++) {
            if (table[m][j] < mostNegative) {
                mostNegative = table[m][j];
                pivotCol = j;
            }
        }

        // No negative â†’ optimal solution reached
        if (pivotCol == -1)
            break;

        // Step 2: Leaving variable using minimum ratio test
        double minRatio = 1e18;
        pivotRow = -1;

        for (int i = 0; i < m; i++) {
            if (table[i][pivotCol] > 0) {
                ratio[i] = table[i][rhs] / table[i][pivotCol];
                if (ratio[i] < minRatio) {
                    minRatio = ratio[i];
                    pivotRow = i;
                }
            }
        }

        if (pivotRow == -1) {
            printf("\nThe solution is UNBOUNDED.\n");
            return 0;
        }

        // Step 3: Pivot operation
        pivot = table[pivotRow][pivotCol];

        for (int j = 0; j <= totalVars; j++)
            table[pivotRow][j] /= pivot;

        for (int i = 0; i <= m; i++) {
            if (i != pivotRow) {
                double factor = table[i][pivotCol];
                for (int j = 0; j <= totalVars; j++)
                    table[i][j] -= factor * table[pivotRow][j];
            }
        }

        basicVar[pivotRow] = pivotCol;

        printTable(table, m, totalVars, basicVar);
    }

    // ---------------- FINAL OUTPUT ----------------
    printf("\nOptimal Solution:\n");
    double result[MAX] = {0};

    for (int i = 0; i < m; i++)
        result[basicVar[i]] = table[i][rhs];

    for (int j = 0; j < n; j++)
        printf("x%d = %.2lf\n", j + 1, result[j]);

    printf("Maximum Z = %.2lf\n", table[m][rhs]);

    return 0;
}
