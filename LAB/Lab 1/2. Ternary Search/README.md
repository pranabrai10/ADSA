# Ternary Search

This program implements **Binary Search** and **Ternary Search**, compares their number of comparisons, and generates a visual graph using **gnuplot**.  
It highlights the practical performance difference between the two logarithmic search methods.

---

## ðŸ“Œ 1. Overview

This program:

- Implements **Binary Search (iterative)**  
- Implements **Ternary Search (recursive)**  
- Tracks the **number of comparisons** each method performs  
- Runs experiments on array sizes ranging from **10 â†’ 100,000**  
- Generates a gnuplot graph comparing both algorithms  

The key goal is to demonstrate that **Binary Search is faster in practice**, despite similar theoretical time complexities.

---

## ðŸ“Œ 2. Files Generated by the Program

### âœ” `output.dat`  
Contains experimental results in the format:

```
n  comparisonsBinary  comparisonsTernary
```

Example:

```
10 3 4
100 7 10
1000 10 15
```

### âœ” gnuplot plot window  
A live graph showing:

- X-axis: Array size (log scale)  
- Y-axis: Number of element comparisons  
- Two lines â†’ Binary vs Ternary  

---

## ðŸ“Œ 3. Program Structure

### ðŸ”¹ Global Counters

```c
int comparisonsBinary = 0;
int comparisonsTernary = 0;
```

These count the number of value comparisons each algorithm performs.

---

### ðŸ”¹ Binary Search

```c
int binarySearch(int arr[], int n, int key);
```

**Process:**

- Iteratively halves the search space  
- Compares key with middle element  
- `comparisonsBinary++` for each comparison  

**Time Complexity:**  
\[
O(\log_2 n)
\]

---

### ðŸ”¹ Ternary Search

```c
int ternarySearch(int arr[], int l, int r, int key);
```

**Process:**

- Splits the range into three parts  
- Computes two midpoints: `mid1` and `mid2`  
- Makes **two comparisons per step**  
- Recursively searches the correct segment  
- `comparisonsTernary += 2` per iteration  

**Time Complexity:**  
\[
O(\log_3 n)
\]

But slower in practice due to extra comparisons.

---

### ðŸ”¹ Main Function

The experiment runs for:

```
10
100
1000
10000
100000
```

For each size:

1. Build sorted array: `arr[i] = i + 1`  
2. Choose key = n (worst case)  
3. Reset comparison counters  
4. Run `binarySearch()`  
5. Run `ternarySearch()`  
6. Write results to `output.dat`  
7. Automatically launch gnuplot to generate the comparison graph  

---

## ðŸ“Œ 4. Graph Details (gnuplot)

The program executes the following commands:

```gnuplot
set title 'Binary Search vs Ternary Search Comparisons'
set xlabel 'Array size (n)'
set ylabel 'Number of Comparisons'
set logscale x
set grid
plot 'output.dat' using 1:2 with linespoints title 'Binary Search', \
     'output.dat' using 1:3 with linespoints title 'Ternary Search'
```

- **Log-scale X-axis** â†’ clearly shows trend across large ranges  
- **Two curves** â†’ comparison of practical performance  

---

## ðŸ“Œ 5. Expected Results

Binary search consistently performs **fewer comparisons** than ternary search:

- Binary search â†’ **1 comparison per iteration**  
- Ternary search â†’ **2 comparisons per iteration**  

Even though ternary search reduces the number of recursive levels slightly,  
the **extra comparisons make it slower**.

You will observe:

```
Binary Search curve is below Ternary Search curve.
```

---

## ðŸ“Œ 6. Complexity Comparison

| Algorithm        | Time Complexity | Comparisons per Step | Practical Performance |
|------------------|-----------------|-----------------------|------------------------|
| Binary Search    | \(O(\log_2 n)\) | 1                     | Faster                |
| Ternary Search   | \(O(\log_3 n)\) | 2                     | Slower                |

**Conclusion:**  
Even though `logâ‚ƒ n < logâ‚‚ n`, the **extra 2 comparisons per step** make ternary search slower in practice.

---

## ðŸ“Œ Conclusion

This program demonstrates:

- How Binary Search and Ternary Search behave in practice  
- Why Binary Search is more efficient  
- How to use comparison-counting to measure algorithmic cost  
- How to generate performance graphs via gnuplot  

An excellent experiment for understanding **algorithmic efficiency beyond Big-O notation**.

